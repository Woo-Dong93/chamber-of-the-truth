# BlockChain

## 1. 블록체인

### 블록체인이란?

- 블록체인이란 블록을 연결한 모음으로, 일정 시간 동안 확정된 거래내역을 블록에 담는 일종의 거래 장부이다.
- 블록체인 기술은 P2P네트워크에서 발생하는 모든 거래(Transaction)정보를 담고 있는 원장(Ledger)을 노드라고 불리는 모든 컴퓨터 장치가 분산 저장 및 업데이트 하고 무결성(Integrity)을 유지하도록 하는 기술이다.
- 기존의 중앙집중식 거래 시스템을 탈중앙화(Decentralization)할 수 있는 핵심 기술로 금융과 암호화폐 분야에 처음 도입돼 활용되고 있다.

### 기본구조

![blockchain_structure](./image/blockchain_structure.png)

- 블록체인은 이전 블록의 정보(해시 값), 현재 거래 정보 및 해시값 등을 포함해 블록을 생성한다.
- 이때문에 블록의 내용을 조작할 수 없으며, 거래 정보가 공개되어 있기때문에 투명한 관리가 가능하다.

![blockchain_structure2](./image/blockchain_structure2.png)

- 누군가 악의적으로 해시값을 변경해 조작한 거래를 담고 있는 블록을 블록체인에 연결할 수 있지만, 블록체인 합의 과정에서 조작된 블록체인은 자연스럽게 제거 된다.

### 특징

- 블록체인은 분산형 원장구조 이며, 블록체인 네트워크에 참여한 모든 사람이 모든 거래내력을 기록한 원장(Ledger)을 소유한다.
- 따라서 별로의 거래관리 기간이 필요없고, 분산화된 거래장부인 블록체인에 의해 작동하므로 시스템 유지비용이 적고 해킹을 차단할 수 있다는 장점이 있다.
- 분산원장 환경에서 사용자가 송금거래를 요청하면, 거래 정보가 기록된 하나의 블록을 생성해 네트워크상의 모든 참여자에게 블록을 전송한다.
- 각 참여자가 전송된 블록을 승인하면 기존 블록체인에 거래 기록이 추가 되면서 거래가 완료된다.

### 원리

- 일반적인 블록체인 네트워크를 구성하는 시스템 구성요소는 노드와 클라이언트 2가지이다.
  - 노드: 트랜잭션 내역 보관, 트랜잭션 승인, 분산합의
  - 클라이언트: 트랜잭션 생성, 거래 내역 확인(지갑)
- 블록체인 노드는 일반적인 서비스의 백엔드 역할을 하고 블록체인 클라이언트는 클라이언트 역할을 한다.
- 클라이언트가 새로운 트랜잭션 발생 -> 노드들은 분산합의 과정을 거침 -> 트랜잭션 공유 및 실행 -> 클라이언트는 트랜잭션의 결과를 확인

### 송금 예를 통한 블록체인 동작과정 

- 실물화폐(Fiat Currency)의 경우 현금을 직접 가지고 있다면, 이를 다른 사람에게 전달할 때는 직접 만나서 현금을 전달하면 된다.
- 하지만 디지털 거래의 경우 실물화폐를 주고 받을 수 없으므로 거래 내용에 맞게 각각의 장부를 갱신해 거래를 완료 해야한다.
  - A가 B에게 100만원을 송금하면 금융기관에 있는 장부에서 A가 B에게 100만원을 보냈다는 기록과 함께, A의 잔고가 100만원 감소하고 B의 잔고가 100만원 증가 한다.
  - 즉, 거래 내용과 잔액의 상태, 두가지 정보가 있고 거래 내역이 검증 되면 잔액의 상태가 변경 된다. 암호화폐 거래 방식도 이와 동일하다.
- 블록체인 기반 암호화폐(Cryptocurrency)의 경우를 보자.
  - 블록체인에 참여하는 모든 노드가 전부 같은 장부를 유지한다것만 다르고 나머지 과정의 위와 비슷하다.
  - 장부를 보유한 노드들은 각자가 금융기관의 역할을 하며, 노드의 과반수 이상이 동의 했을 때, 영구적으로 장부에 기록이 된다.
  - 과반수 합의 방식은 투표와 비슷하지만, 한 명이 하나의 투표권을 가지는 선거제도와 달리 블록체인은 블록이 생성되는 합의 과정에서 가장 많은 작업을 한 노드가 어느 기록이 진짜인지 결정할 수 있는 권한을 더 많이 가진다. 이것을 작업증명(Proof of Work)이라 부르며 비트코인, 이더리움 등 주요 블록체인에서 채택하고 있는 방식이다.
  - 새로운 블록을 블록체인에 추가하려면, 새로운 블록의 해시값을 계산해야하고, 이 해시값을 얻기 위해서는 블록의 헤더 정보 중 하나인 Nonce 값을 구해야 한다. 결론적으로 이 Nonce값을 구하는 것이 바로 작업증명이다.

### 블록의 구성

![blockchain_structure3](./image/blockchain_structure3.png)

- 블록은 일반적으로 블록 해시, 블록헤더, 거래 정보로 구성되어 있다.
- 비트코인이나 이더리움에서 사용하는 블록 헤더의 주요한 6가지 정보는 다음과 같다.

![blockheader](./image/blockheader.PNG)

- 거래 정보는 보낸 사람 주소, 받는 사람 주소, 금액 등 입출금과 관련한 여러 가지 정보를 가진다.
- 블록 내에는 이 외에도 다양한 기타 정보를 담을 수 있다.
- 일반적으로 이 정보들은 블록 해시 계산에는 사용되지 않는다.

### 블록체인 개발 플랫폼의 변화

![version](./image/version.PNG)

- 블록체인 기술은 본래 비트코인이라는 전자화폐를 안전하게 저장하고 사용하기 위해 고안된 보안 기술이다.

- 스마트 컨트랙트는 일정한 조건을 만족하는 경우 거래가 자동으로 실행될 수 이도록 프로그래밍된 자동화 계약 시스템이다.

- 2.0시대의 문제점..

  - 네트워크가 이미 포화된 상태에서 검증에 많은 시간 소요, 거래 승인까지 하루 이상이 걸리기도 했음.

  - 페이스북, 구글과 같은 확실한 서비스 운영 주체가 없는 블록체인 생태계는 플랫폼 업그레이드를 위한 합의 도출이 어려무여, 운영 주체간 대립으로 하드포크(블록체인 프로토콜이 어느 한 시점에서 급격하게 변경돼 두 갈래로 나뉘는 것)도 발생함.

### 블록체인 분류

![classification](./image/classification.PNG)

- 퍼블릭 블록체인(Public BlockChain): 비트코인, 이더리움과 같은 누구나 네트워크에 참여할 수 있는 블록체인
- 프라이빗 블록체인(Private BlockChain):  하나의 기관에서 독자적으로 사용하는 블록체인
- 컨소시엄 블록체인(Consortium BlockChain): 여러 기관들이 컨소시엄을 이뤄 구성하는 블록체인으로, 허가된 기관만 네트워크에 참여 가능



# HyperLedger Fabric 

## 1. 개념 및 용어 설명

### HyperLedger Fabric?

-  하이퍼레저 프로젝트는 리눅스 재단에서 주관해 세계 여러 기업들이 공동으로 참여하고 있는 '범산업용 분산원장 표준화 프로젝트'다.

- 하이퍼레저 프로젝트는 6개의 프레임인워크(Fabric, Iroha, Swathooth, Burrow, Indy, Grid)와 6개의 툴(Quilt, Composer, Explorer, Cello, Caliper, Ursa)로 구성된다.
- 하이퍼레저 패브릭은
  - 모듈러 아키텍처 기반의 애플리케이션/솔루션 개발 프레임워크로 컨센서스(합의)알고리즘이나 멤버십 서비스 등 핵심 기술 요소를 Plug-and-Play 방식으로 구현할 수 있도록 지원한다.
  - 컨테이너 기술을 활용해 시스템의 애플리케이션 로직을 구성할 수 있도록 체인코드 서비스를 제공한다.
  - 여러가지 플러그 가능 옵션을 제공한다
    - 컨센서스 알고리즘: Kafka기반 오더링 서비스, Raft 알고리즘
    - MSP(Membership Service Provider) 서비스를 통해 다양한 확장성 제공
  - 엔터프라이즈 수준의 설계를 고려한 허가형 블록체인이다. 
- 1세대 블록체인 비트코인, 2세대 블록체인 이더리움은 서로 신뢰의 여부를 확인할 수 없는 많은 사람들이 모여서 공개적으로 합의하고 타임스탬프와 전자 서명을 통해 새로운 합의된 신뢰를 만들 수 있다.  -> 하이퍼레저에 참여하고있는 기관들은 이 합의 시스템을 "시간이 걸리는 이상적인 제안" 으로 간주하고 있다.
- 블록체인의 스마트 컨트랙트(Smart contract)이 기존에 존재하는 많은 자산의 흐름을 대신할 수 있지만, 현실세계의 많은 계약들은 기밀성을 요구하고 있다. 따라서 누구든지 원하는 사람은 모두 참여할 수 있는 공개된 네트워크가 아니라 가입이 통제되고 회원 관리가 가능한 권한형/허가형 블록체인(Permissioned BlockChain)이 필요하다는 것이 하이퍼레저 프로젝트에 참여하고 있는 기관들의 논리이다.

### 하이퍼레저 패브릭의 목표

- 허가된 참여자를 대상으로 하는 비즈니스 응용 환경에 맞는 블록체인
- 다양한 요구사항을 가진 분산 응용 서비스를 효율적으로 지원할 수 있는 개발 플랫폼
- 모듈러 아키텍처 기반 분산 응용 플랫폼(컨센선스 알고리즘, 멤버십 서비스 등 모듈을 필요에 따라 교체 가능

### 주요 특징

- 허가형 블록체인
  - MSP를 통해 허가된 참여자만 접근을 허용/제어 할 수 있다.
- 일반 프로그래밍 언어 사용
  - Go, Java와 같은 일반적으로 많이 사용되는 언어로 개발할 수 있다.
- 높은 성능
  - 서로 다른 Endorsing Peer Node에게 체인코드를 실행시키도록 할 수 있다.
  - 키에 대한 버전 관리를 통해 동시 처리에 따른 비 결정적 실행 문제점을 해결해 높은 성능을 낸다.
- 교체 가능한 모듈러 아키텍처
  - 오더링 서비스 노드에서 순서화를 통해 3가지 컨센서스 알고리즘을 선택할 수 있다. Solo, Kafka, PBFT
- 멀티 블록체인 지원
  - 채널이라는 분할된 네트워크로 멀티 블록체인을 지원한다.
  - 하나의 블록체인 네트워크를 논리적으로 독립된 여러 개의 블록체인으로 분할할 수 있다.

### 구조 및 용어 설명

#### [Architecture]

![architectures](./image/architectures.png)

- 신원확인
  - 사용자가 하이퍼레저 패브릭의 네트워크에 접속하려면 신원확인을 가장 먼저 해야함.
  - 신원확인은 MSP(MemberShip Service Provider)를 통해 이뤄짐.
- 원장
  - 블록에 트랜잭션(거래) 정보가 실제로 저장되는 공간이다.
  - 블록체인의 데이터를 관리하는 분산원장 데이터베이스를 가르키며, 이를 관리 및 처리 하기 위한 기능으로 구성돼 있다.
  - World State라는 저장소에 저장한다.
  - 한 채널이 한 원장을 가지며, 한 채널 안에 속한 피어 노드는 동일한 원장의 복사본을 가진다.
  - 원장은 업데이트되며 채널 안에서 합의를 통해 일관성을 유지한다.
- 트랜잭션
  - 스마트 컨트랙트인 체인코드의 실행을 의미한다.
  - 엔도싱 피어(Endorsing Peer)노드를 통해 보증 검증(Endorsement Validation)과 트랜잭션을 배치 처리한다.
  - 오더링 서비스(Ordering Service)노드를 통해 프라이빗 블록체인 네트워크에 참여하고 있는 모든 피어 노드들에 분기하는 역할을 수행한다.
- 체인코드
  - 체인코드를 통해 프라이빗 블록체인에서 기업 및 컨소시엄으로 구성된 서비스에 맞게 블록체인을 활용할 수 있도록 비즈니스 로직을 구현할 수 있다.

#### [용어]

##### 명세서 기반

- HyperLedger Fabric CA(Certificate Authority): 멤버십 서비스를 구축하는 용도이다. 기관, 관리자, 사용자들의 인증서를 발급할 수 있다.
- Transaction: 데이터를 장부에 기록하거나 함수를 호출할 때 블록체인에 전송하는 요청 또는 거래이다. 패브릭에서의 트랜잭션은 체인코드에 의해 통신 채널 별로 구현된다.
- Chaincode: 체인코드는 패브릭에서 제공하는 스마트 컨트랙트로 Go, Java, Node.js 등의 언어를 지원한다. 체인코드는 패브릭 네트워크의 전역상태(World State)를 관리할 수 있는 트랜잭션을 발생시키며, 보안이 적용된 도커 컨테이너를 실행하여 동작한다. 체인코드는 패브릭이 동작하는 근원이라고 할 수 있으며, 서비스에 필요한 비즈니스 로직을 함수 별로 구현하여 상황에 적합한 트랜잭션을 발생시킬 수 있다.
- Consensus: 블록체인에서 가장 중요한 것 중 하나인 합의를 담당하는 요소이다. 하이퍼레저는 여러가지 합의 과정을 도입하여 사용할 수 있는 확장성을 가지고 있으며, 1.4버전까지는 Kafka기반, Raft 두 가지를 선택할 수 있다. 하이퍼레저에서는 정렬 서비스(Ordering Service)를 이용하여 합의를 수행한다. 정렬 서비스는 Orderer라는 역할의 구성원이 제공해 주며 수신한 트랜잭션을 블록으로 묶어 일괄적으로 처리한다.
- Ledger: 패브릭에서는 데이터 저장 및 관리를 위해 데이터베이스를 운용하고 있다. 현재는 기본 DB인 Level DB와 조금 더 복잡한 로직의 쿼리를 지원하는 Couch DB 두 가지를 선택하여 사용할 수 있다. Chaincode로 인해 발생하는 모든 거래를 불변하게 기록하게 된다.
- Peer: 체인코드 및 원장의 관리를 담당하는 참여자이다. Orderer로 부터 정렬된 트랜잭션을 수힌하면 이를 검증하고 최종적으로 블록체인에 저장하기 위해 검증을 수행하고 제출한다. Peer는 다시 Committing Peer와 Endorsing Peer로 구분된다. Committing Peer는 원장과 상태를 유지하고, Endorsing Peer는 트랜잭션 제안을 승인 또는 거절할 수 있는 역할을 수행한다.

##### IBM 공식 문서 기반

- Transactor: 트랜잭션(거래)를 일으키는 엔티티를 말한다. 대표적으로 클라이언트 애플리케이션이다.
- Transaction: 트랜잭션은 블록체인 네트워크에 대해사 비즈니스 로직을 수행하기 위한 요청이다. 트랜잭션의 유형은 deploy, invoke, query 이며, 체인코드를 통해서 사전 정의된 인터페이스에 대한 함수를 구현한다.
- World State: 트랜잭션에 의해서 체인코드가 호출될 때 상태 및 데이터 저장을 위한 Key-value 데이터베이스다.
- Chaincode: 다양한 트랜잭션의 유형을 구현한 블록체인에 임베드되는 로직이다. 개발자에 의해 체인코드가 작성되고 블록체인 네트워크로 디플로이 한다. 최종 사용하는 블록체인 네트워크를 구성하는 피어 또는 노드와 인터페이스 되어 있는 클라이언트 애플리케이션을 통해서 체인코드를 실행시킨다. 체인코드는 트랜잭션을 일으키고 유효성이 확인되면 공유원장에 추가하고 World State를 수정한다.
- Validating Peer(VP): 블록체인 네트워크에서 원장을 관리 유지하기 위해서 트랜잭션의 유효성을 검증하는 합의 프로토콜을 실행하는 노드이다. 검증된 트랜잭션은 원장에 블록단위로 추가 된다. 트랜잭션이 합의에 실패하면 블록에서 제거되므로 장부에 기록되지 않는다. Validating Peer는 체인코드를 deploy, invoke, query할 권한을 가진다.
- Non-Validating Peer(NVP): Transactor가 Validating Peer에 접속할 수 있도록 프록시 역할을 하는 노드이다. Non-Validating Peer는 호출된 요청을 Validating Peer에 접속할 수 있도록 프록시 역할을 하는 노드이다. Non-Validating Peer는 호출된 요청을 Validating Peer로 전달하며, 이벤트 스트림, REST 서비스를 담당하는 노드이다.
- Consensus: 블록체인 네트워크의 트랜잭션 순서를 유지하는 프로토콜, Validating 노드들은 합의 프로토콜을 구현하여 트랜잭션을 승인하기 위해서 함께 동작한다.
- Permissioned Network: 각 노드는 블록체인 네트워크에서 접근 권한을 관리해야 하는 노드이며, 각 노드는 권한이 있는 사용자만 접근할 수 있다.

##### 교재 기반

- 채널(Channel): 네트워크에서 구성 요소 간 그룹을 나눠 트랜잭션을 수행해야 할 때 사용한다. 트랜잭션의 접근 권한을 그룹별로 설정하고 관리하는 중요한 프라이빗 블록체인 기술 요소다.

- 조직(Organization): 네트워크는 조직 단위로 구성되는데, 조직 별로 피어 노드 관리 및 부여, 보증 정책 등을 수행한다. 또한 클라이언트, 즉 참여자의 접근 권한도 관리한다.

- 피어노드(Peer Node): 가장 기본적인 네트워크 구성 요소로, 블록체인 네트워크를 유지하고 트랜잭션의 제안 및 응답을 처리하며, 원장과 체인코드를 관리하고 저장하는 역할을 수행한다. 피어 노드는 역할에 따라 다음과 같은 4가지로 세분화 될 수 있다.
  - 엔도싱 피어 노드(Endorsing Peer Node): 보증 정책에 따라 요청된 트랜잭션을 먼저 실행해보는 검토 역할을 수행한 후 트랜잭션에 트랜잭션 보증 사인을 첨부하는 역할을 한다.
  - 커미팅 피어 노드(Committing Peer Node): 엔도싱 피어 노드가 실행한 트랜잭션 결과를 검증문제가 없으면 트랜잭션을 확정하고 그 내용을 블록체인에 업데이트 하는 역할을 한다.
  - 앵커 피어 노드(Anchor Peer Node): 채널 내에서 대표 역할을 수행하는 피어 노드다.
  - 리더 피어 노드(Leader Peer Node): 조직에서 모든 피어 노드를 대표한다.
  -  여기에서 언급한 노드는 일종의 물리적인 시스템 단위로 블록체인 네트워크를 구성하는 서버다.
  - 블록체인은 중앙에서 관리하는 서버는 없지만 블록체인 네트워크에 참여해 이를 활성화시키는 수많은 서버들이 있는데, 이 서버들이 노드다.
  - 하이퍼레저 패브릭에는 피어노드에게 트랜잭션을 전달해 전체 블록체인 네트워크가 작동하도록 컨트롤하는 오더링 서비스 노드가 존재한다.
  
- 오더링서비스: 네트워크에 참여하고 있는 모든 피어 노드의 분기 및 정렬 역할을 한다.

  - 오더러(Orderer)라고도 부르며, 네트워크 내의 채널에 대한 구성 ㅈ어보를 소유하고 이를 기반으로 전체 시스템의 관리자 역할을 수행한다.

  - 클라이언트로부터 트랜잭션을 제안 받으면, 시간 순서에 따라 차례로 정리해 피어 노드에게 전달한다.

  - 또한, 트랜잭션 정보를 네트워크에 반영해 새로운 블록을 추가하고 업데이트하며 관리한다.

  - Solo 오더링 서비스: 가장 기본적인 알고리즘으로 하나의 중앙집중형 오더링 서비스가 모든 트랜잭션의 순서를 결정한다. 상용화가 아닌 테스트 용도로 적합하다.

  - Kafka 기반 오더링 서비스: Pub/Sub 구조의 메시지큐 미들웨어인 카프카 기반의 오더링 서비스로, 시스템의 결함으로 인해 피어 노드가 멈췄을 때 다른 분산 오더링 서비스를 제공할 수 있다.

    *비잔티움 문제에 노출돼 있는 한계가 있음. 비잔티움 문제란 블록체인 기술에서 매 순간 새로운 블록들이 생성되는 과정에서 각 노드는 서로를 신뢰하지 않으며, 악의를 가진 노드에 의해 모순된 거래가 생성될 수있다는 문제.

  - RAFT(Reliable, Replicated, Redundant, And Fault-Tolerant) 오더링 서비스: 하이퍼레저 패브릭 1.4.1버전부터 추가된 CFT(Crash Fault Tolerant) 알고리즘 기반 오더링 스비스다. 

- MSP: 멤버십 서비스 제공자, 즉 블록체인 네트워크에 인증 서비스를 제공하는 역할을 한다. 다시 말해 MSP는 블록체인 네트워크에 참여하는 피어 노드, 오더링 서비스 노드 등 각 노드의 신원, 역할, 소속, 권한을 관리하고 조직 구조를 설계하는 역할을 한다. 또한 블록체인 네트워크에 접속하려는 클라이언트의 신원을 확인하고 접근 권한을 제공한다.

- CA(Certification Authority): MSP에서 암호화 인증을 위해 필요한 인증기관이며, 공개키 인증서 및 이에 대응하는 개인 키를 발급한다. 블록체인 네트워크를 구성하는 조직에게는 루트 인증서(Root Certificate)를, 블록체인 네트워크에 접속하는 사용자에게는 신원등록 인증서(Enrollment Certificate, Ecert) 발급한다.



### 하이퍼레저 패브릭 시스템 플로우





### 그래서 Peer가 뭐야?

#### [peer]

![Peer](./image/Peer.png)

- 블록체인 네트워크는 Peer들의 집합으로 이루어져 있다.
- Peer는 원장 상태(Ledger State)와 체인코드(Chaincode)를 관리하는 네트워크 노드이다.
- Peer들은 Ledgers와 Chaincode(Smart Contracts)를 호스팅하는 블록체인 네트워크의 기본적인 요소이다. 
- Ledger는 Chaincode로 인해 발생하는 모든 거래를 불변하게 기록하게 된다.
- Chaincode와 Ledger는 각각 공유 프로세스와 정보를 네트워크에 캡슐화하는데 사용된다.

#### [Block Network]

![blockchain_network](./image/blockchain_network.png)

- 블록체인 네트워크는 Peer로 구성되며 각 Peer는 Ledger 사본과 Chaincode 사본을 보유할 수 있다.
- 네트워크 N은 Peer P1, P2, P3로 구성되어 있으며 각 Peer는 분산 Ledger L1의 자체 인스턴스를 유지관리한다.
- P1, P2, P3는 동일한 Chaincode S1을 사용하여 L1 사본에 엑세스한다.

#### [Multiple Ledgers]

![blockchain_multipleledger](./image/blockchain_multipleledger.png)

- Peer는 둘 이상의 Ledger를 호스팅할 수 있으므로 유연한 시스템 설계가 가능하다.
- 단순한 구성은 Peer가 단일 Ledger를 관리하는 것이지만 필요할 때는 둘 이상의 Ledger를 호스팅하는 것이 적합할 수 있다.
- Peer는 하나 이상의 Ledger를 호스팅하고 각 Ledger는 0개 이상의 Chaincode가 적용된다.
- Peer P1이 Ledger L1, L2를 호스팅하고 있으며, Ledger L1은 Chaincode S1을 사용하여 엑세스 된다.
- L2는 Chaincode S1, S2를 사용하여 엑세스 할 수 있다.

#### [Multiple Chaincode]

- Peer가 가지고 있는 Ledger 수와 해당 Ledger에 접근할 수 있는 Chaincode의 수는 고정되어 있지 않다.
- Peer는 많은 Chaincode와 Ledger를 사용할 수 있다.

#### [Application and Peers]

![application](./image/application.png)

- Peer는 Orderer와 함께 모든 Ledger가 최신 상태로 유지되도록 한다.

- Application A는 Peer P1에 연결하고 Chaincode S1을 호출하여 Ledger L1을 query 또는 upgrade 한다.

  -> 체인코드가 이미 install 되어있다고 가정함.

- Peer P1은 Chaincode S1을 호출하여 query의 결과 또는 Proposal(제안/신청)된  Ledger 갱신을 포함하는 Proposal Response를 생성한다.

- Application A는 Proposal Response를 수신하고 query의 경우 프로세스가 완료된다.

- update의 경우 Application A는 모든 Response에 대해 Transaction을 생성하여 Order(정렬?)을 위해 Orderer에게 전송한다.

- Orderer O1은 수집한 Transaction을 모든 Peer에 배포하며, Peer P1은 Ledger L1에 적용하기 전에 Transaction의 유효성을 검사한다.

- Ledger L1이 update가 되면 Peer P1은 Application A가 수신할 수 있는 이벤트를 생성하고 완료된다.

#### [Transaction Flow]

![transaction](./image/transaction.png)

- Peer는 query요청에 만족 시킬 수 있는 모든 정보가 Peer's Ledger 사본에 있으므로 query 결과를 즉시 Application에 반환할 수 있다. 또한 query를 위해 다른 Peer들과 통신할 필요가 없다.

- 그러나 Application은 하나 이상의 Peer를 연결하여 query를 발행할 수 있다. 예를들어 여러 Peer간에 결과를 확증하거나 정보가 오래되었다는 의심이 들 경우 다른 Peer들에서 최신 결과를 검색할 수 있다.

- Update Transaction은 Query Transaction와 동일한 방식으로 시작되지만 추가적인 단계가 있다.

  -> Ledger Update Application은 Ledger Query Application과 달리 Chaincode를 호출하기 위해 Peer에 연결되지만, 개별 Peer에 Update를 수행할 수 없다. 다른 Peer들이 먼저 변경사항에 대해 동의를 해야하기 때문이다.

  -> 동의하는 절차를 Consensus(합의)라고 부른다. 따라서 Peer는 Proposal Update(다른 Peer들에게 사전 동의를 받아 적용될 업데이트)를 Application에 반환한다.

  -> Application은 Proposal Update와 일치하는 적절한 집합을 Peer 전체 네트워크에 보내어 각 Ledger에 대해 Commit을 위해 Transaction을 요구합니다.

  -> 이것은 Orderer를 사용하여 Transaction을 블록으로 패키징하고 이를 Peer의 전체 네트워크에 분배하여 각 Peer의 Ledger사본에 적용되기 전에 확인 할 수 있다.

  -> 이 전체 Order 처리가 완료되기까지 몇시간이 걸리므로 Application은 비동적으로 응답을 전해받는다.

#### [Peers and Cahnnels]

![channel](./image/channel.png)

- Channel: 블록체인 네트워크 내의 구성요소로 개인적으로 통신하고 거래할 수 있는 매커니즘.
- 구성요소는 일반적으로 Peer, Orderer, Application이며, 채널에 가입함으로써 공동 작업을 통해 해당 채널에 연결된 Ledger의 동일한 복사본을 공동으로 공유하고 관리하는데 동의 되어진다.

#### [Peers and Organization]

![organization](./image/organization.png)

- 블록체인 네트워크는 조직의 집합에 의해 관리된다. Peer들은 이러한 종류의 분산 네트워크가 어떻게 구성되어있는지에 대한 핵심 역할을 한다.
- 여러 조직과 블록체인 네트워크에 있는 Peer들, 블록체인 네트워크는 소유된 Peer들과 조직들의 기여로 구성된다. 위 그림은 네트워크 형성을 위해 4개의 조직에 기여가 되는 8개의 Peer를 볼 수 있다.
- Channel C는 블록체인 네트워크 N에서 Peer P1, P3, P5, P7, P8을 연결한다.
- Channel C에 가입하지 않았지만 일반적으로 모든 Peer는 하나 이상의 Channel에 가입을 한다.
- 특정조직에서 개발한 Application은 다른 조직의 Application과 마찬가지로 자신의 조직 Peer와 연결되게 된다.
- 네트워크는 리소스를 제공하는 여러 조직에 의해 형성되고 관리 되어진다. Peer는 이 항목에서 논의 중인 리소스 이지만 조직에서 제공해주는 리소스는 단순한 것 이상이다.
